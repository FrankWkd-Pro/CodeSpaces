1.[饲养母鸡](https://oj.czos.cn/contest/problem?id=21083&pid=3)
```cpp
/*  
重温经典离散化  
思路：我们只需要将对应的区间加上对应的数值，然后找最大的就行啦  
*/  
#include <bits/stdc++.h>  
using namespace std;  
  
int a[40020], s[40020];  
int l[40020], r[40020];  
int k, n, x, y, z;  
  
int main() {  
    cin >> n >> x >> y >> z;  
    for (int i = 1; i <= n; i++) {  
        cin >> l[i] >> r[i];  
        s[++k] = l[i];  
        s[++k] = r[i];  
    }  
    sort(s + 1, s + 1 + k);  
    k = unique(s + 1, s + 1 + k) - s - 1;  
    for (int i = 1; i <= n; i++) {  
        l[i] = lower_bound(s + 1, s + 1 + k, l[i]) - s;  
        r[i] = lower_bound(s + 1, s + 1 + k, r[i]) - s;  
        a[l[i]] += y;  
        a[r[i] + 1] -= y;  
        a[1] += x;  
        a[l[i]] -= x;  
        a[r[i] + 1] += z;  
        a[k + 1] -= z;  
    }  
    for(int i = 1;i <= k;i++){  
        a[i] += a[i-1];  
    }  
    int anss = 0,ii = 0;  
    for(int i = 1;i <= k/*这里一定要是k呀*/;i++){  
        if(a[i] > anss){  
            anss = a[i],ii =i;  
        }  
    }  
    cout<<anss<<endl;  
}
```
2.B3694 数列离散化
```cpp
#include <bits/stdc++.h>
using namespace std;
//题目就是个恶心的阅读理解，硬是把离散化给你解释了一遍，秒切~
int n, a[10101010], b[1010100];
int main() {
	int t;
	cin >> t;
	while (t--) {
		cin >> n;
		int k = n;
		for (int i = 1; i <= n; i++) {
			cin >> a[i];
			b[i] = a[i];
		}
		sort(b + 1, b + 1 + n);
		k = unique(b + 1, b + 1 + n) - b - 1;
		for (int i = 1; i <= n; i++) {
			cout << lower_bound(b + 1, b + 1 + k, a[i]) - b << " ";
		}
		puts("");
	}
}
```


3.三个火枪手
- 所有的问题都出在计算power上，最开始是进制搞错了，然后结果这个根本用不到。
```cpp
#pragma GCC optimize(2)
#include <bits/stdc++.h>
using namespace std;
const int N = 2e6+10,P = 131;
typedef unsigned long long ull;
char s[N];
ull h[N],p[N];
//我们简化一下，直接把去重的过程给ban掉，直接set.insert就行。
//最后如果set里面啥也没有，我们就NOT POSSIBLE 如果set.size > 1就NOT UNIQUE.
//左右两部分里面一定有一部分是完好无损的。直接记录是哪一部分即可。然后输出完好无损的那个部分就行啦
int n;
set <ull> st;
void gethash() {
	p[0] = 1;
	for(int i = 1; i <= n; i++) {
		p[i] = p[i-1]*P;
		h[i] = h[i-1]*P+s[i]-'A'+1;
	}
}
ull power(int k){
	return p[k];
}
ull get1(int l,int r){
	return h[r]-h[l-1]*p[r-l+1];
}
bool is_l = 0;
int mid;
int main(){
	scanf("%d%s",&n,s+1);
	gethash();
	mid = n+1>>1;
	for(int i = 1;i <= n;i++){
		if(i == 1){
			ull ans1 = get1(i+1,mid);
			ull ans2 = get1(mid+1,n);
			if(ans2 != ans1) continue;
			is_l = 0;
			st.insert(ans1);
		}else if(i > 1 and i < mid){
			ull ans1 = get1(1,i-1)*power(mid-i)+get1(i+1,mid);
			ull ans2 = get1(mid+1,n);
			if(ans2 != ans1) continue;
			is_l = 0;
			st.insert(ans1);
		}else if(i == mid){
			ull ans1 = get1(1,mid-1);
			ull ans2 = get1(mid+1,n);
			if(ans2 != ans1) continue;
			is_l = 0;
			st.insert(ans1);
			
		}else if(i > mid and i < n){
			ull ans1 = get1(1,mid-1);
			ull ans2 = get1(mid,i-1)*power(n-i)+get1(i+1,n);
			if(ans2 != ans1) continue;
			is_l = 1;
			st.insert(ans1);
		}else if(i == n){
			ull ans1 = get1(1,mid-1);
			ull ans2 = get1(mid,n-1);
			if(ans2 != ans1) continue;
			is_l = 1;
			st.insert(ans1);
		}
		if(st.size() > 1){
			puts("NOT UNIQUE");
			return 0;
		}
	}
	if(st.size() == 0){
		puts("NOT POSSIBLE");
		return 0;
	}
	if(is_l == 1){
		for(int i = 1;i <= mid-1;i++){
			printf("%c",s[i]);
		}
	}else{
		for(int i = mid+1;i <= n;i++){
			printf("%c",s[i]);			
		}
	}
}
```